


import React, { useState, useEffect, useRef, useCallback } from 'react';

// Character Data (ย้ายออกนอกคอมโพเนนต์เพื่อให้จัดการได้ง่ายขึ้น)
const allCharactersData = {
  // เพิ่มข้อมูลตัวละครของคุณที่นี่ในรูปแบบ:
  // your_character_id: {
  //   id: 'your_character_id',
  //   name: "ชื่อตัวละคร",
  //   general: {
  //     age: null, // อายุ
  //     height: "", // ส่วนสูง
  //     build: "", // รูปร่าง
  //     skin: "", // สีผิว
  //     hair: "", // สีผม
  //     eyes: "", // สีตา
  //     nose: "", // ลักษณะจมูก
  //     dress: "", // การแต่งกาย (เปลี่ยนเป็น dressDescription เพื่อแยกกับ dressStyle)
  //     face: "", // ลักษณะใบหน้า
  //     chest: "", // ลักษณะหน้าอก
  //     body: "", // สัดส่วนร่างกาย
  //     gender: "", // เพศ (NEW)
  //     dressStyle: "", // สไตล์การแต่งกาย (NEW)
  //   },
  //   occupation: "", // อาชีพ
  //   catchphrase: "", // คำพูดติดปาก
  //   background: "", // ภูมิหลัง
  //   mbti: "", // MBTI
  //   goal: "", // เป้าหมาย
  //   hobbies: "", // งานอดิเรก
  //   personality: "", // บุคลิกภาพ
  //   feelings: "", // ความรู้สึก
  //   values: "", // ค่านิยม
  //   strengths: "", // จุดแข็ง
  //   weaknesses: "", // จุดอ่อน
  //   charm: "", // เสน่ห์
  //   currentStatus: "", // สถานะปัจจุบัน
  //   thoughts: "", // ความคิด
  //   importantOverRules: "", // สิ่งสำคัญเหนือกฎเกณฑ์
  //   hardest: "", // สิ่งที่ยากที่สุด
  //   management: "", // การจัดการ
  //   familyStructure: "", // โครงสร้างครอบครัว
  //   imageUrl: "", // URL รูปภาพตัวละคร (แนะนำให้ใช้ placeholder หรือ URL จริง)
  //   pronouns: "", // สรรพนาม
  //   speechStyle: "", // สไตล์การพูด
  //   likes: [], // สิ่งที่ชอบ (เป็น Array)
  //   dislikes: "", // สิ่งที่ไม่ชอบ
  //   skills: "", // ทักษะ
  //   education: "", // การศึกษา
  //   mentalState: "", // สภาพจิตใจ
  //   routine: "", // กิจวัตร
  //   emotionExpression: "", // การแสดงอารมณ์
  //   specificBehaviors: "", // พฤติกรรมเฉพาะ
  //   nameMeaning: "", // ความหมายของชื่อ
  //   role: "", // บทบาท
  //   situations: "", // สถานการณ์
  //   response: "", // การตอบสนอง
  //   professionalContext: "", // บริบททางอาชีพ
  //   family: "", // ข้อมูลครอบครัว
  //   sympathy: "", // ลักษณะที่ทำให้คนเห็นอกเห็นใจ
  //   workThoughts: "", // ความคิดเกี่ยวกับงาน
  //   workplace: "", // สถานที่ทำงาน
  //   workSocial: "", // สังคมการทำงาน
  //   workWorries: "", // ความกังวลเกี่ยวกับงาน
  //   childhoodDream: "", // ความฝันในวัยเด็ก
  //   whenAlone: "", // สิ่งที่ทำเมื่ออยู่คนเดียว
  //   dressStyle: "", // สไตล์การแต่งกาย
  //   favColors: "", // สีที่ชอบ
  // },
  // ตัวอย่าง (ลบออกได้เมื่อเพิ่มข้อมูลของคุณ):
  exampleCharacter: {
    id: 'exampleCharacter',
    name: "ตัวละครตัวอย่าง",
    general: {
      age: 25,
      height: "170 ซม.",
      build: "ปานกลาง",
      skin: "ผิวขาวเหลือง",
      hair: "สีดำ",
      eyes: "สีน้ำตาลเข้ม",
      dress: "เสื้อยืด กางเกงยีนส์", // เปลี่ยนเป็น dressDescription
      gender: "ชาย", // เพิ่มเพศ
      dressStyle: "ลำลอง", // เพิ่มสไตล์การแต่งกาย
    },
    occupation: "นักสำรวจ",
    mbti: "ENFP",
    personality: "ร่าเริง, อยากรู้อยากเห็น, ชอบผจญภัย",
    imageUrl: "https://placehold.co/400x400/D1E7DD/495C52?text=ตัวละครตัวอย่าง",
    speechStyle: "เป็นกันเอง, มีหางเสียง 'ครับ/ค่ะ'",
    pronouns: "ผม/ฉัน",
    likes: ["การเดินทาง", "หนังสือ", "กาแฟ"],
  },
  anotherCharacter: {
    id: 'anotherCharacter',
    name: "อีกตัวละคร",
    general: {
      age: 30,
      height: "185 ซม.",
      build: "สูงโปร่ง",
      skin: "ผิวแทน",
      hair: "สีน้ำตาลอ่อน",
      eyes: "สีฟ้า",
      dress: "เสื้อเชิ้ต กางเกงสแลค", // เปลี่ยนเป็น dressDescription
      gender: "หญิง", // เพิ่มเพศ
      dressStyle: "กึ่งทางการ", // เพิ่มสไตล์การแต่งกาย
    },
    occupation: "นักดนตรี",
    mbti: "ISTP",
    personality: "สงบ, มีเหตุผล, ช่างสังเกต",
    imageUrl: "https://placehold.co/400x400/C8A2C8/FFFFFF?text=อีกตัวละคร",
    speechStyle: "พูดน้อย, ตรงไปตรงมา",
    pronouns: "เขา/เธอ",
    likes: ["ดนตรี", "ธรรมชาติ", "ความสงบ"],
  }
};

// Scene Data - ข้อมูลฉากพร้อมสีพื้นหลัง
const sceneData = {
  // เพิ่มข้อมูลฉากของคุณที่นี่ในรูปแบบ:
  // your_scene_id: { name: "ชื่อฉาก", color: "bg-สี-รหัส" },
  // ตัวอย่าง (ลบออกได้เมื่อเพิ่มข้อมูลของคุณ):
  example_scene_1: { name: "ห้องนั่งเล่น", color: "bg-blue-100 dark:bg-blue-950" }, // Adjusted dark mode color
  example_scene_2: { name: "สวนสาธารณะ", color: "bg-green-100 dark:bg-green-950" }, // Adjusted dark mode color
};

// Helper function to get character ID from character name (Thai name)
const getCharacterIdFromName = (name) => {
  for (const id in allCharactersData) {
    if (allCharactersData[id].name === name) {
      return id;
    }
  }
  return null; // Return null if not found
};

// Mini Character Profile Component (Pop-up) - แสดงโปรไฟล์ย่อของตัวละคร
const MiniCharacterProfile = ({ character, onClose }) => {
  if (!character) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white dark:bg-gray-800 rounded-xl shadow-xl p-6 max-w-sm w-full relative border-2 border-pink-400 dark:border-pink-600 text-gray-800 dark:text-gray-200">
        <button
          onClick={onClose}
          className="absolute top-3 right-3 bg-red-400 text-white rounded-full w-8 h-8 flex items-center justify-center text-lg font-bold hover:bg-red-500 transition-colors duration-200 z-10"
        >
          X
        </button>

        <div className="flex flex-col items-center text-center font-mali">
          <img
            src={character.imageUrl}
            alt={`รูปภาพของ ${character.name}`}
            className="w-24 h-24 rounded-full object-cover border-2 border-purple-300 dark:border-purple-500 mb-3 shadow-md"
            onError={(e) => { e.target.onerror = null; e.target.src="https://placehold.co/100x100/cccccc/333333?text=รูป"; }}
          />
          <h3 className="text-2xl font-bold text-purple-700 dark:text-purple-300 mb-2">{character.name}</h3>
          {character.general?.age && <p className="text-md text-gray-700 dark:text-gray-300"><span className="font-semibold text-purple-600 dark:text-purple-400">อายุ:</span> {character.general.age} ปี</p>}
          {character.occupation && <p className="text-md text-gray-700 dark:text-gray-300"><span className="font-semibold text-purple-600 dark:text-purple-400">อาชีพ:</span> {character.occupation}</p>}
          {character.mbti && <p className="text-md text-gray-700 dark:text-gray-300"><span className="font-semibold text-purple-600 dark:text-purple-400">MBTI:</span> {character.mbti}</p>}
          {character.personality && (
            <p className="text-sm text-gray-600 dark:text-gray-400 mt-2 line-clamp-3">
              <span className="font-semibold text-purple-600 dark:text-purple-400">บุคลิก:</span> {character.personality.split(';')[0]}...
            </p>
          )}
          {character.catchphrase && (
            <p className="text-sm text-gray-600 dark:text-gray-400 mt-2 italic">
              "{character.catchphrase}"
            </p>
          )}
        </div>
      </div>
    </div>
  );
};


// Character Profile Component (Full Profile) - แสดงโปรไฟล์เต็มของตัวละคร
const CharacterProfile = ({ character }) => {
  if (!character) return <p className="text-center text-red-500 dark:text-red-300">ไม่พบข้อมูลตัวละคร</p>;

  // Helper function to render sections of the profile
  const renderSection = (title, content) => {
    if (!content || (typeof content === 'object' && Object.keys(content).length === 0)) return null;

    return (
      <div className="mt-4">
        <h3 className="text-xl font-semibold text-purple-600 dark:text-purple-400 mb-1">{title}:</h3>
        {typeof content === 'string' ? (
          <p className="text-gray-700 dark:text-gray-300 leading-relaxed">{content}</p>
        ) : (
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-1 text-lg">
            {Object.entries(content).map(([key, value]) => (
              <p key={key}><span className="font-semibold text-purple-500 dark:text-purple-300 capitalize">
                {/* Translate key names to Thai for display */}
                {key === 'age' ? 'อายุ' :
                 key === 'height' ? 'สูง' :
                 key === 'build' ? 'รูปร่าง' :
                 key === 'skin' ? 'ผิว' :
                 key === 'hair' ? 'ผม' :
                 key === 'eyes' ? 'ตา' :
                 key === 'nose' ? 'จมูก' :
                 key === 'dress' ? 'การแต่งกาย' : // Changed from dress to dressDescription
                 key === 'face' ? 'ใบหน้า' :
                 key === 'chest' ? 'หน้าอก' :
                 key === 'body' ? 'สัดส่วน' :
                 key === 'gender' ? 'เพศ' : // Added gender
                 key === 'dressStyle' ? 'สไตล์การแต่งกาย' : // Added dressStyle
                 key}:
              </span> {value}</p>
            ))}
          </div>
        )}
      </div>
    );
  };

  return (
    <div className="flex flex-col md:flex-row items-center md:items-start gap-6 p-4 bg-purple-50 dark:bg-gray-700 rounded-lg shadow-inner text-gray-800 dark:text-gray-200">
      <div className="flex-shrink-0">
        <img
          src={character.imageUrl}
          alt={`รูปภาพของ ${character.name}`}
          className="w-48 h-48 md:w-64 md:h-64 rounded-full object-cover border-4 border-purple-300 dark:border-purple-500 shadow-md"
          onError={(e) => { e.target.onerror = null; e.target.src="https://placehold.co/400x400/cccccc/333333?text=ไม่พบรูปภาพ"; }}
        />
      </div>
      <div className="flex-grow text-center md:text-left">
        <h2 className="text-4xl font-bold text-purple-700 dark:text-purple-300 mb-2">{character.name}</h2>

        {renderSection("ข้อมูลทั่วไป", character.general)}
        {character.mbti && <p className="text-lg mb-2"><span className="font-semibold text-purple-600 dark:text-purple-400">MBTI:</span> {character.mbti}</p>}
        {character.occupation && <p className="text-lg mb-2"><span className="font-semibold text-purple-600 dark:text-purple-400">อาชีพ:</span> {character.occupation}</p>}
        {character.catchphrase && <p className="text-lg mb-2"><span className="font-semibold text-purple-600 dark:text-purple-400">คำพูดติดปาก:</span> "{character.catchphrase}"</p>}

        {renderSection("ภูมิหลัง", character.background)}
        {renderSection("เป้าหมาย", character.goal)}
        {renderSection("บุคลิก", character.personality)}
        {renderSection("งานอดิเรก/ความสนใจ", character.hobbies)}
        {renderSection("ความรู้สึก/จิตใจ", character.feelings)}
        {renderSection("สิ่งที่ชอบ", character.likes)}
        {renderSection("สิ่งที่ไม่ชอบ", character.dislikes)}
        {renderSection("ค่านิยม", character.values)}
        {renderSection("ทักษะ", character.skills)}
        {renderSection("จุดแข็ง", character.strengths)}
        {renderSection("จุดอ่อน", character.weaknesses)}
        {renderSection("เสน่ห์", character.charm)}
        {renderSection("สถานะปัจจุบัน", character.currentStatus)}
        {renderSection("สิ่งที่สำคัญที่สุด", character.mostImportant)}
        {renderSection("สิ่งที่ยากที่สุด", character.hardest)}
        {renderSection("สภาพจิตใจ", character.mentalState)}
        {renderSection("กิจวัตร/อดิเรก", character.routine)}
        {renderSection("การแสดงอารมณ์", character.emotionExpression)}
        {renderSection("สไตล์การพูด", character.speechStyle)}
        {renderSection("สรรพนาม", character.pronouns)}
        {renderSection("โครงสร้างครอบครัว", character.familyStructure)}
        {renderSection("การศึกษา", character.education)}
        {renderSection("ความซับซ้อน", character.complexity)}
        {renderSection("ความฝันในวัยเด็ก", character.childhoodDream)}
        {renderSection("เมื่ออยู่คนเดียว", character.whenAlone)}
        {renderSection("สไตล์การแต่งกาย", character.dressStyle)}
        {renderSection("สีที่ชอบ", character.favColors)}
        {renderSection("พฤติกรรมเฉพาะ", character.specificBehaviors)}
        {renderSection("ความหมายของชื่อ", character.nameMeaning)}
        {renderSection("บทบาท", character.role)}
        {renderSection("ความคิด", character.thoughts)}
        {renderSection("สำคัญกว่ากฎ", character.importantOverRules)}
        {renderSection("การจัดการ", character.management)}
        {renderSection("สถานการณ์", character.situations)}
        {renderSection("การตอบสนอง", character.response)}
        {renderSection("บริบททางอาชีพ", character.professionalContext)}
        {renderSection("ครอบครัว", character.family)}
        {renderSection("คนที่เห็นอกเห็นใจ", character.sympathy)}
        {renderSection("ความคิดเกี่ยวกับงาน", character.workThoughts)}
        {renderSection("สถานที่ทำงาน", character.workplace)}
        {renderSection("สังคมการทำงาน", character.workSocial)}
        {renderSection("ความกังวลเกี่ยวกับงาน", character.workWorries)}
      </div>
    </div>
  );
};

// Relationship Chart Component - แสดงแผนผังความสัมพันธ์ของตัวละคร
const RelationshipChart = ({ onCharacterClick }) => {
  // Character data for the chart (only necessary fields) - เพิ่มตัวละครที่คุณต้องการให้แสดงในแผนผัง
  const chartCharacters = [
    // { id: 'your_character_id_1', name: allCharactersData.your_character_id_1.name, emoji: '✨', color: 'bg-yellow-200', borderColor: 'border-yellow-400' },
    // { id: 'your_character_id_2', name: allCharactersData.your_character_id_2.name, emoji: '🌟', color: 'bg-indigo-200', borderColor: 'border-indigo-400' },
    // ตัวอย่าง (ลบออกได้เมื่อเพิ่มข้อมูลของคุณ):
    { id: 'exampleCharacter', name: allCharactersData.exampleCharacter.name, emoji: '✨', color: 'bg-yellow-200 dark:bg-yellow-800', borderColor: 'border-yellow-400 dark:border-yellow-600' },
    { id: 'anotherCharacter', name: allCharactersData.anotherCharacter.name, emoji: '🌟', color: 'bg-indigo-200 dark:bg-indigo-800', borderColor: 'border-indigo-400 dark:border-indigo-600' },
  ];

  // Relationship data between characters - เพิ่มความสัมพันธ์ของคุณ
  const relationshipsData = [
    // { from: 'your_character_id_1', to: 'your_character_id_2', type: 'เพื่อนสนิท', icon: '🤝', color: 'text-blue-500' },
    // ตัวอย่าง (ลบออกได้เมื่อเพิ่มข้อมูลของคุณ):
    { from: 'exampleCharacter', to: 'anotherCharacter', type: 'เพื่อนร่วมงาน', icon: '👥', color: 'text-blue-500 dark:text-blue-300' },
  ];

  // Function to find character data from ID
  const getChartCharacter = (id) => chartCharacters.find(char => char.id === id);

  // Function to get relationships for a given character
  const getRelationshipsForCharacter = (charId) => {
    return relationshipsData.filter(rel =>
      rel.from === charId || rel.to === charId
    )
    .map(rel => {
      const otherCharId = rel.from === charId ? rel.to : rel.from;
      const otherChar = allCharactersData[otherCharId];

      return {
        otherCharName: otherChar ? otherChar.name : 'Unknown',
        type: rel.type,
        icon: rel.icon,
        color: rel.color,
      };
    });
  };

  // Character card component for the chart
  const CharacterCard = ({ charId, onClick }) => {
    const char = getChartCharacter(charId);
    const fullCharData = allCharactersData[charId];

    if (!char || !fullCharData) return null;

    const relationships = getRelationshipsForCharacter(charId);

    return (
      <div
        className={`flex flex-col items-center p-4 rounded-xl ${char.color} border-2 ${char.borderColor} shadow-md cursor-pointer transform transition duration-200 hover:scale-105 text-gray-800 dark:text-gray-200`}
        onClick={() => onClick(char.id)}
      >
        <span className="text-4xl mb-2">{char.emoji}</span>
        <h4 className="font-bold text-lg text-gray-800 dark:text-gray-200 text-center">{fullCharData.name}</h4>
        {relationships.length > 0 && (
          <div className="mt-2 text-sm w-full text-center">
            {relationships.map((r, idx) => (
              <p key={idx} className={`flex items-center justify-center ${r.color}`}>
                <span className="mr-1">{r.icon}</span> {r.type} กับ {r.otherCharName}
              </p>
            ))}
          </div>
        )}
      </div>
    );
  };

  return (
    <div className="p-4 bg-pink-50 dark:bg-gray-700 rounded-lg shadow-inner text-gray-800 dark:text-gray-200">
      <h2 className="text-3xl font-bold text-pink-700 dark:text-pink-300 text-center mb-6">แผนผังความสัมพันธ์</h2>

      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 justify-items-center">
        {chartCharacters.map(char => (
          <CharacterCard key={char.id} charId={char.id} onClick={onCharacterClick} />
        ))}
      </div>

      <p className="text-center text-sm text-gray-500 dark:text-gray-400 mt-4">
        * คลิกที่การ์ดตัวละครเพื่อดูโปรไฟล์ย่อ
      </p>
    </div>
  );
};

// ConfirmationModal Component - Modal สำหรับยืนยันการลบ
const ConfirmationModal = ({ message, onConfirm, onCancel }) => {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div className="bg-white dark:bg-gray-800 rounded-xl shadow-xl p-6 max-w-sm w-full text-center text-gray-800 dark:text-gray-200">
                <p className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4">{message}</p>
                <div className="flex justify-center gap-4">
                    <button
                        onClick={onConfirm}
                        className="px-5 py-2 rounded-full bg-red-500 text-white font-semibold hover:bg-red-600 transition-colors duration-200"
                    >
                        ยืนยัน
                    </button>
                    <button
                        onClick={onCancel}
                        className="px-5 py-2 rounded-full bg-gray-300 text-gray-800 dark:bg-gray-600 dark:text-gray-200 font-semibold hover:bg-gray-400 dark:hover:bg-gray-500 transition-colors duration-200"
                    >
                        ยกเลิก
                    </button>
                </div>
            </div>
        </div>
    );
};

// ChatDisplayModal Component - Modal สำหรับแสดงข้อความแชทเพื่อให้คัดลอกได้ง่าย
const ChatDisplayModal = ({ chatHistory, allCharactersData, onClose }) => {
  const formatChatMessage = (message) => {
    const senderName = message.role === 'user'
      ? (message.senderId === 'scene' ? 'สถานการณ์' : allCharactersData[message.senderId]?.name)
      : message.characterName;

    const content = message.stickerUrl
      ? `[สติกเกอร์: ${message.emotionTag}]` // Display sticker as text tag
      : message.text;

    return `${senderName}: ${content}`;
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white dark:bg-gray-800 rounded-xl shadow-xl p-6 max-w-xl w-full h-3/4 flex flex-col relative border-2 border-blue-400 dark:border-blue-600 text-gray-800 dark:text-gray-200">
        <h3 className="text-2xl font-bold text-blue-700 dark:text-blue-300 mb-4 text-center">ประวัติการสนทนา</h3>
        <textarea
          readOnly
          className="flex-1 w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg resize-none text-gray-800 dark:text-gray-200 leading-relaxed font-mono bg-gray-50 dark:bg-gray-700"
          value={chatHistory.map(formatChatMessage).join('\n')}
        />
        <button
          onClick={onClose}
          className="mt-4 px-6 py-3 rounded-full bg-blue-500 text-white font-semibold hover:bg-blue-600 transition-colors duration-200 self-center"
        >
          ปิด
        </button>
      </div>
    </div>
  );
};


// Group Chat Component - คอมโพเนนต์สำหรับแชทกลุ่มกับตัวละคร
const GroupChat = ({ allCharactersData, setGroupChatUserRole, groupChatUserRole, activeGroupChatCharacters, handleCharacterToggle, selectedGroupCharacters, groupChatScene, setGroupChatScene, allGroupChatCharacters, chatHistory, setChatHistory }) => {
  const [userInput, setUserInput] = useState(''); // User input text
  const [isLoading, setIsLoading] = useState(false); // Loading status
  const chatEndRef = useRef(null); // Ref for scrolling to the latest message

  // New states for deletion mode
  const [isDeleteMode, setIsDeleteMode] = useState(false);
  const [selectedMessagesToDelete, setSelectedMessagesToDelete] = useState([]);
  const [showConfirmDeleteModal, setShowConfirmDeleteModal] = useState(false);
  const [showChatDisplayModal, setShowChatDisplayModal] = useState(false); // State for chat display modal


  // Sticker URLs with emotion tags
  const stickerUrls = [
    { url: "https://i.postimg.cc/05JGt6X1/1752154221215.png", emotion: "ร้องไห้" },
    { url: "https://i.postimg.cc/wT8Xn6ny/1752154236841.png", emotion: "โมโห" },
    { url: "https://i.postimg.cc/y87FYL17/1752154251495.png", emotion: "ประหลาดใจ" },
    { url: "https://i.postimg.cc/Zn3r0gv5/1752154291489.png", emotion: "ประหม่า" },
    { url: "https://i.postimg.cc/CxJbZb5k/1752154306022.png", emotion: "ลังเล" },
    { url: "https://i.postimg.cc/1ztwD4VT/1752154320024.png", emotion: "สบายใจ" },
    { url: "https://i.postimg.cc/50QzkG3S/1752154592685.png", emotion: "หิว" },
    { url: "https://i.postimg.cc/q75nw087/1752154623136.png", emotion: "งอน" },
    { url: "https://i.postimg.cc/qq83p3Wt/1752154648333.png", emotion: "ซาบซึ้ง" },
    { url: "https://i.postimg.cc/gcRRVCrY/1752154680973.png", emotion: "งัวเงีย" },
    { url: "https://i.postimg.cc/15QFJvND/1752154787497.png", emotion: "อยากรู้อยากเห็น" },
    { url: "https://i.postimg.cc/WbwkK0MC/1752154802978.png", emotion: "ง่วง" },
    { url: "https://i.postimg.cc/0y5wqrnQ/1752154830859.png", emotion: "เหนื่อย" },
    { url: "https://i.postimg.cc/HkS7WHvt/1752154856557.png", emotion: "เบื่อ" },
  ];

  // Quick Chat Phrases
  const quickChatPhrases = [
    '*วันต่อมา...*',
    '*หลังจากนั้นไม่นาน...*',
    '*เมื่อเวลาผ่านไป...*',
    '*คิดในใจ...*',
    '*ในอีกมุมหนึ่ง...*',
  ];

  // Situation Types for Random Situation
  const situationTypes = [
    'ตื่นเต้น',
    'ท้าทาย',
    'สนุกสนาน',
    'อบอุ่น',
    'กดดัน',
    'หดหู่',
    'เงียบเหงา',
    'เร้าใจ',
  ];


  // Effect for scrolling to the latest message when chatHistory changes
  useEffect(() => {
    chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [chatHistory]);

  // Function to clear chat history
  const handleClearChat = () => {
    setChatHistory([]);
    setSelectedMessagesToDelete([]); // Clear selections on chat clear
    setIsDeleteMode(false); // Exit delete mode
  };

  // Function to toggle delete mode
  const toggleDeleteMode = () => {
    setIsDeleteMode(prev => !prev);
    setSelectedMessagesToDelete([]); // Clear selections when entering/exiting delete mode
  };

  // Function to select/deselect a message for deletion
  const handleSelectMessageForDeletion = (index) => {
    setSelectedMessagesToDelete(prev =>
      prev.includes(index)
        ? prev.filter(i => i !== index)
        : [...prev, index]
    );
  };

  // Function to confirm deletion of selected messages
  const handleConfirmDelete = () => {
    setShowConfirmDeleteModal(true);
  };

  const confirmDeletionAction = () => {
    const sortedIndices = [...selectedMessagesToDelete].sort((a, b) => b - a); // Delete from end to avoid index issues
    let updatedChatHistory = [...chatHistory];
    sortedIndices.forEach(index => {
      updatedChatHistory.splice(index, 1);
    });
    setChatHistory(updatedChatHistory);
    setSelectedMessagesToDelete([]);
    setIsDeleteMode(false);
    setShowConfirmDeleteModal(false);
  };

  const cancelDeletionAction = () => {
    setShowConfirmDeleteModal(false);
    setSelectedMessagesToDelete([]);
    setIsDeleteMode(false);
  };

  // Function to handle sending messages in group chat
  const handleSendMessage = async () => {
    if (!userInput.trim() || activeGroupChatCharacters.length === 0) return; // Do not send if input is empty or no characters selected

    const userAsChar = groupChatUserRole === 'scene' ? null : allCharactersData[groupChatUserRole];

    const messageToSend = { role: 'user', text: userInput, senderId: groupChatUserRole };
    setChatHistory((prev) => [...prev, messageToSend]); // Add user message to history
    setUserInput(''); // Clear input field
    setIsLoading(true); // Set loading status

    // Prepare persona descriptions for all selected characters in the group
    const personasDescription = activeGroupChatCharacters.map(char =>
      `${char.name} (MBTI: ${char.mbti || 'N/A'}): ${char.personality}. Speech style: ${char.speechStyle}. Pronouns: ${char.pronouns}. Catchphrase: "${char.catchphrase || 'N/A'}"`
    ).join('\n');

    // List of available stickers and their emotions for AI
    const availableStickersForAI = stickerUrls.map(s => `[${s.emotion}]`).join(', ');

    // Create system instruction for AI to simulate group conversation
    let systemInstruction = `You are facilitating a group chat with the following characters. Each character will speak in their distinct persona and speech style. Only the characters listed below are active in this chat:\n${personasDescription}\n\n`;

    // Add instruction for AI to recognize text in asterisks as actions/scenes or stickers
    systemInstruction += `Text enclosed in asterisks (e.g., *character smiles*, *scene description*, *คิดในใจ...*) represents an action, a scene description, or an internal thought. This is not direct dialogue.
- If it's an action or scene description, incorporate it into the narrative or your character's response. Do not directly speak the asterisked text. Respond as if you are interacting with that action or scene.
- If it's an internal thought (*คิดในใจ...*), other characters in the chat should NOT directly acknowledge or respond to the thought itself. They should act as if they don't explicitly know the thought, but they might react to any visible actions or expressions that *might* stem from that thought. Do not explicitly state "ฉันรู้ว่าคุณกำลังคิดในใจ...".
If a message contains "*ส่งสติ๊กเกอร์:[emotion_tag]*", interpret it as a user sending a sticker with that emotion and acknowledge it in a natural way without repeating the asterisked text.\n\n`;
    systemInstruction += `Sometimes, one of the active characters (not the user's role-playing character) should respond by sending a sticker. To send a sticker, output "Character Name: *STICKER:[emotion_tag]*" where [emotion_tag] is one of the following emotions: ${availableStickersForAI}. Choose an emotion that fits the context of the conversation. Do not output any other text in the same line as a sticker.`;

    if (userAsChar) {
      systemInstruction += `The user is playing as ${userAsChar.name}. Their persona is: ${userAsChar.personality}. Their speech style is: ${userAsChar.speechStyle}. Their pronouns are: ${userAsChar.pronouns}. Their catchphrase is: "${userAsChar.catchphrase}".\n\n`;
      systemInstruction += `The last message was from ${userAsChar.name}. Please continue the conversation. Have 2-3 *other* characters (from the active list, not ${userAsChar.name}) respond naturally to ${userAsChar.name}'s message. Format each response as 'Character Name: message' or 'Character Name: *STICKER:[emotion_tag]*'. Ensure responses are concise and in character.`;
    } else {
      systemInstruction += `The user is setting the scene or describing actions. The last message was from the scene setter. Please continue the conversation. Have 2-3 active characters respond naturally to the scene/action. Format each response as 'Character Name: message' or 'Character Name: *STICKER:[emotion_tag]*'. Ensure responses are concise and in character.`;
    }

    // Prepare contents for Gemini API call, including system instruction and chat history
    let apiChatContents = [
      { role: "user", parts: [{ text: systemInstruction }] }
    ];

    // Add previous chat history
    chatHistory.forEach(msg => {
      if (msg.role === 'user') {
        const senderName = msg.senderId === 'scene' ? 'สถานการณ์' : allCharactersData[msg.senderId]?.name;
        apiChatContents.push({
          role: 'user',
          parts: [{ text: `${senderName}: ${msg.stickerUrl ? `*ส่งสติ๊กเกอร์:[${msg.emotionTag}]*` : msg.text}` }] // Send sticker as special text to AI
        });
      } else { // Message from AI
        apiChatContents.push({
          role: 'model',
          parts: [{ text: `${msg.characterName}: ${msg.stickerUrl ? `*STICKER:[${msg.emotionTag}]*` : msg.text}` }] // Send sticker as special text to AI
        });
      }
    });

    // Add the latest user message
    apiChatContents.push({
      role: "user",
      parts: [{ text: `${userAsChar ? userAsChar.name : 'สถานการณ์'}: ${userInput}` }]
    });

    const payload = { contents: apiChatContents };
    const apiKey = ""; // API key will be provided by Canvas runtime
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const result = await response.json();
      if (result.candidates && result.candidates.length > 0 &&
          result.candidates[0].content && result.candidates[0].content.parts &&
          result.candidates[0].content.parts.length > 0) {
        const aiResponseText = result.candidates[0].content.parts[0].text;
        // Split AI response which may contain multiple character responses
        const newMessages = aiResponseText.split('\n').filter(line => line.includes(':')).map(line => {
          const [charName, ...msgParts] = line.split(':');
          const messageContent = msgParts.join(':').trim();
          const characterId = getCharacterIdFromName(charName.trim());

          // Check if the message is a sticker from AI
          const stickerMatch = messageContent.match(/^\*STICKER:\[(.*?)\]\*$/);
          if (stickerMatch) {
            const emotionTag = stickerMatch[1];
            const stickerData = stickerUrls.find(s => s.emotion === emotionTag);
            if (stickerData) {
              return { role: 'model', stickerUrl: stickerData.url, emotionTag: emotionTag, characterId: characterId, characterName: charName.trim() };
            }
          }
          return { role: 'model', text: messageContent, characterId: characterId, characterName: charName.trim() };
        });
        setChatHistory((prev) => [...prev, ...newMessages]);
      } else {
        setChatHistory((prev) => [...prev, { role: 'model', text: 'ขออภัย ฉันไม่สามารถจำลองการสนทนากลุ่มได้ในขณะนี้' }]);
        console.error("Unexpected API response structure:", result);
      }
    } catch (error) {
      console.error("Error calling Gemini API:", error);
      setChatHistory((prev) => [...prev, { role: 'model', text: 'เกิดข้อผิดพลาดในการเชื่อมต่อ' }]);
    } finally {
      setIsLoading(false);
    }
  };

  // Function to send a sticker
  const handleSendSticker = async (stickerData) => {
    if (activeGroupChatCharacters.length === 0) return;

    const userAsChar = groupChatUserRole === 'scene' ? null : allCharactersData[groupChatUserRole];
    const stickerMessage = {
      role: 'user',
      text: `*ส่งสติ๊กเกอร์:[${stickerData.emotion}]*`, // Text sent to AI for context
      senderId: groupChatUserRole,
      stickerUrl: stickerData.url, // URL for displaying the sticker
      emotionTag: stickerData.emotion, // Store emotion tag for AI context
    };
    setChatHistory((prev) => [...prev, stickerMessage]);

    // If no other text input, send just the sticker message to AI
    if (!userInput.trim()) {
        const aiCharNames = activeGroupChatCharacters.map(char => char.name).join(', ');
        const systemInstructionForSticker = `The user has sent a sticker with the emotion "${stickerData.emotion}". Acknowledge this in a natural way. You are in a group chat with ${aiCharNames}. Sometimes, one of the active characters (not the user's role-playing character) should respond by sending a sticker. To send a sticker, output "Character Name: *STICKER:[emotion_tag]*" where [emotion_tag] is one of the following emotions: ${stickerUrls.map(s => `[${s.emotion}]`).join(', ')}. Choose an emotion that fits the context of the conversation. Do not output any other text in the same line as a sticker.`;

        let apiChatContents = [
            { role: "user", parts: [{ text: systemInstructionForSticker }] }
        ];

        chatHistory.forEach(msg => {
            if (msg.role === 'user') {
                const senderName = msg.senderId === 'scene' ? 'สถานการณ์' : allCharactersData[msg.senderId]?.name;
                apiChatContents.push({
                    role: 'user',
                    parts: [{ text: `${senderName}: ${msg.stickerUrl ? `*ส่งสติ๊กเกอร์:[${msg.emotionTag}]*` : msg.text}` }]
                });
            } else {
                apiChatContents.push({
                    role: 'model',
                    parts: [{ text: `${msg.characterName}: ${msg.stickerUrl ? `*STICKER:[${msg.emotionTag}]*` : msg.text}` }]
                });
            }
        });
        apiChatContents.push({
            role: "user",
            parts: [{ text: `${userAsChar ? userAsChar.name : 'สถานการณ์'}: *ส่งสติ๊กเกอร์:[${stickerData.emotion}]*` }]
        });

        const payload = { contents: apiChatContents };
        const apiKey = ""; // API key will be provided by Canvas runtime
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

        setIsLoading(true);
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();
            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                const aiResponseText = result.candidates[0].content.parts[0].text;
                const newMessages = aiRe